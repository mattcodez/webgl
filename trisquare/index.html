<html>

<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="js/glMatrix-2.2.0.js"></script>
<script type="text/javascript" src="js/webgl-utils.js"></script>
<script type="text/javascript" src="OBJ_WebGL/js/obj.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
	precision mediump float;

	varying vec2 vTextureCoord;

	uniform sampler2D uSampler;

	void main(void) {
		gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
	}
</script>

<script id="shader-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec2 aTextureCoord;

	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;

	varying vec2 vTextureCoord;

	void main(void) {
		gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		vTextureCoord = aTextureCoord;
	}
</script>


<script type="text/javascript">
"use strict";
    var gl;

    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }


    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }


    var shaderProgram;

    function initShaders() {
		var fragmentShader = getShader(gl, "shader-fs");
		var vertexShader = getShader(gl, "shader-vs");

		shaderProgram = gl.createProgram();
		gl.attachShader(shaderProgram, vertexShader);
		gl.attachShader(shaderProgram, fragmentShader);
		gl.linkProgram(shaderProgram);

		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
			alert("Could not initialise shaders");
		}

		gl.useProgram(shaderProgram);

		shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
		gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

		shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
		gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

		shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
		shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
		shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
    }


    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();

    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.copy(copy, mvMatrix);
        mvMatrixStack.push(copy);
    }

    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }


    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
    }


    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

	var drawList = [];
    function initBuffers(mapname) {
		var worldObjects = objjs.loadObject(mapname);
		
		for (var i = 0; i < worldObjects.length; i++){
			var object = worldObjects[i];
			
			var vertexPositionBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(object.verticies), gl.STATIC_DRAW);
			vertexPositionBuffer.itemSize = 3;
			vertexPositionBuffer.numItems = object.vertexCount;

			var vertexTextureCoordBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, vertexTextureCoordBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(object.textureCoords), gl.STATIC_DRAW);
			vertexTextureCoordBuffer.itemSize = 2;
			vertexTextureCoordBuffer.numItems = object.vertexCount;
			
			var drawItem = {
				vertexPositionBuffer: 		vertexPositionBuffer,
				vertexTextureCoordBuffer: 	vertexTextureCoordBuffer,
				texture:					object.texture
			};
			
			drawList.push(drawItem);
		}
    }
	
	var textures = {};
	function initTextures(data){
		var texturePaths = objjs.loadMatl(data);
		
		for (var textureName in texturePaths){
			var path = texturePaths[textureName];
			
			var glTexture = gl.createTexture();
			glTexture.image = new Image();
			glTexture.image.onload = function () {
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
				gl.bindTexture(gl.TEXTURE_2D, glTexture);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, glTexture.image);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
				
				gl.bindTexture(gl.TEXTURE_2D, null);
			}
			glTexture.image.src = path;
			
			textures[textureName] = {
				path:		path,
				glTexture:	glTexture
			};
		}
	}

    var cameraPos = [-5, 7, 4];
	var cameraLook = [-5, 7, 5]; 
	var cameraPan = [0,0,0]; //Z will always be zero
	var cameraUp = [0,1,0]; //Static
	
	var pitch = degToRad(-27);
	var yaw = degToRad(-20);
	
	var movementSpeed = 0.1;
	var cameraPanSpeed = 0.2;
	var crouchingDelta = 0;
	
	function handleMotion(){
		/**	
		Some of the math code taken from the HTML5 Rocks PointerLock tutorial
		under the Apache 2.0 Licence
		http://www.html5rocks.com/en/tutorials/pointerlock/intro/
		http://www.apache.org/licenses/LICENSE-2.0	
		**/
		
		yaw -= degToRad(cameraPan[0] * 100);
		pitch -= degToRad(cameraPan[1] * 100);
		
		crouchingDelta = motion.crouching ? -3 : 0;
		
		var forwardDirection = vec3.create(cameraLook);
		vec3.subtract(forwardDirection, cameraLook, cameraPos);

		var strafeScale = 0.0;
		strafeScale += motion.strafeLeft ? 1.0 : 0.0;
		strafeScale -= motion.strafeRight ? 1.0 : 0.0;
		var strafeMovement = vec3.create();
		if (strafeScale !== 0.0){
			vec3.cross(strafeMovement, forwardDirection, cameraUp);
			vec3.scale(strafeMovement, strafeMovement, strafeScale * movementSpeed);
		}
		
		//vec3.subtract(this.lookAtPoint, this.eyePoint, frontDirection);
		vec3.normalize(forwardDirection, forwardDirection);
		var q = quat.create();
		// Construct quaternion 
		quat.setAxisAngle(q, cameraUp, yaw);
		// Rotate camera look vector
		//quat.multiplyVec3(q, forwardDirection);
		vec3.transformQuat(forwardDirection, forwardDirection, q);
		// Update camera look vector
		//this.lookAtPoint = vec3.create(this.eyePoint);
		//vec3.add(this.lookAtPoint, frontDirection);
		
		var forwardScale = 0.0;
		forwardScale += motion.backward ? 1.0 : 0.0;
		forwardScale -= motion.forward ? 1.0 : 0.0;
		
		vec3.scale(forwardDirection, forwardDirection, forwardScale * movementSpeed);
		var allMovement = vec3.create();
		vec3.add(allMovement, strafeMovement, forwardDirection);
		
		vec3.add(cameraPos, cameraPos, allMovement);
		vec3.add(cameraLook, cameraLook, allMovement);
	}
	
	function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.perspective(pMatrix, degToRad(45), gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);
		
        mat4.identity(mvMatrix);
		mat4.rotateX(mvMatrix, mvMatrix, -pitch);
		mat4.rotateY(mvMatrix, mvMatrix, -yaw);
		//TODO: Move crouchingDelta to handleMotion()
		mat4.translate(mvMatrix, mvMatrix, [-cameraPos[0], -(cameraPos[1] + crouchingDelta), -cameraPos[2]]);
		
		for (var i = 0; i < drawList.length; i++){
			var worldObject = drawList[i];
			
			if (worldObject.texture){
				gl.bindBuffer(gl.ARRAY_BUFFER, worldObject.vertexTextureCoordBuffer);
				gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, worldObject.vertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
			}
			
			gl.bindBuffer(gl.ARRAY_BUFFER, worldObject.vertexPositionBuffer);
			gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, worldObject.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
			
			if (worldObject.texture){
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, textures[worldObject.texture].glTexture); 
				gl.uniform1i(shaderProgram.samplerUniform, 0);
			}
				
			setMatrixUniforms();
			gl.drawArrays(gl.TRIANGLES, 0, worldObject.vertexPositionBuffer.numItems);
		}
    }

    function tick() {
        requestAnimFrame(tick);
		handleMotion();
        drawScene();
    }
	
    function webGLStart() {
		function pointerLockChange(){
			if (document.webkitPointerLockElement == canvas){
				//We're toggling into pointer lock
				document.addEventListener("mousemove", onMouseMove, false);
			}
			else {
				//We're toggling out of pointer lock
				document.removeEventListener("mousemove", onMouseMove, false);
			}
		}
		
        var canvas = document.getElementById("gameviewbox");
        initGL(canvas);
        initShaders()
        //loadObject('glMap.obj', initBuffers);
		//initBuffers('glMap');
		loadObject('glMap.obj', function(mapdata){
			objjs.handleLoadedObject(mapdata, gl);
		});
		//loadObject('glMap.mtl', initTextures);

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
		
		document.onkeydown = handleKeyDown;
		document.onkeyup = handleKeyUp;
		
		var requestPointerLock = canvas.webkitRequestPointerLock;
		if (requestPointerLock) {
			canvas.addEventListener('click', requestPointerLock, false);
			document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
		}

		var exitPointerLock = document.webkitExitPointerLock;
		//exitPointerLock();

        tick();
    }
	
	function loadObject(path, callback) {
		var request = new XMLHttpRequest();
		request.open("GET", path);
		request.onreadystatechange = function () {
			if (request.readyState == 4) {
				callback(request.responseText);
			}
		}
		request.send();
	}
	
	function onMouseMove(e){
		//Movement event often gets stuck on a 1 or -1 so camera just keeps rotating, ignore for now
		var moveX = e.webkitMovementX;
		var moveY = e.webkitMovementY;
		moveX = (Math.abs(moveX) == 1 ? 0 : moveX);
		moveY = (Math.abs(moveY) == 1 ? 0 : moveY);
		
		//For now, cameraPan values represent the percentage of the viewport that has been transversed by input (i.e. mouse)
		cameraPan[0] = moveX / gl.viewportWidth;
		cameraPan[1] = moveY / gl.viewportHeight;
	}
	
	var currentlyPressedKeys = {};
	var motion = {};
	function handleKeyDown(event){
		currentlyPressedKeys[event.which] = true;
		
		switch(event.which){
			case 87: // "W"
				motion.forward = true;
				break;
			
			case 83: // "S"
				motion.backward = true;
				break;
				
			case 65: // "A"
				motion.strafeLeft = true;
				break;
				
			case 68: // "D"
				motion.strafeRight = true;
				break;
				
			case 17: // Ctrl
				motion.crouching = true;
				break;
		}
	}
	
	function handleKeyUp(event){
		delete currentlyPressedKeys[event.which];
		
		switch(event.which){
			case 87: // "W"
				motion.forward = false;
				break;
			
			case 83: // "S"
				motion.backward = false;
				break;
				
			case 65: // "A"
				motion.strafeLeft = false;
				break;
				
			case 68: // "D"
				motion.strafeRight = false;
				break;
				
			case 17: // Ctrl
				motion.crouching = false;
				break;
		}
	}

</script>

</head>


<body onLoad="webGLStart();">
	<div align="center">
    	<canvas id="gameviewbox" style="border: none;" width="900" height="600"></canvas>
    </div></body>
</html>
