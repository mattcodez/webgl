<html>
	<head>
		<title>Learning WebGL &mdash; lesson 10</title>
		<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

		<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
		<script type="text/javascript" src="webgl-utils.js"></script>

		<script id="shader-fs" type="x-shader/x-fragment">
		    precision mediump float;
		
		    varying vec2 vTextureCoord;
		
		    uniform sampler2D uSampler;
		
		    void main(void) {
		        gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
		    }
		</script>
		
		<script id="shader-vs" type="x-shader/x-vertex">
		    attribute vec3 aVertexPosition;
		    attribute vec2 aTextureCoord;
		
		    uniform mat4 uMVMatrix;
		    uniform mat4 uPMatrix;
		
		    varying vec2 vTextureCoord;
		
		    void main(void) {
		        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		        vTextureCoord = aTextureCoord;
		    }
		</script>
		
		<script type="text/javascript">
		
		    var gl;
		
		    function initGL(canvas) {
		        try {
		            gl = canvas.getContext("experimental-webgl");
		            gl.viewportWidth = canvas.width;
		            gl.viewportHeight = canvas.height;
		        } catch (e) {
		        }
		        if (!gl) {
		            alert("Could not initialise WebGL, sorry :-(");
		        }
		    }
		
		    function getShader(gl, id) {
		        var shaderScript = document.getElementById(id);
		        if (!shaderScript) {
		            return null;
		        }
		
		        var str = "";
		        var k = shaderScript.firstChild;
		        while (k) {
		            if (k.nodeType == 3) {
		                str += k.textContent;
		            }
		            k = k.nextSibling;
		        }
		
		        var shader;
		        if (shaderScript.type == "x-shader/x-fragment") {
		            shader = gl.createShader(gl.FRAGMENT_SHADER);
		        } else if (shaderScript.type == "x-shader/x-vertex") {
		            shader = gl.createShader(gl.VERTEX_SHADER);
		        } else {
		            return null;
		        }
		
		        gl.shaderSource(shader, str);
		        gl.compileShader(shader);
		
		        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		            alert(gl.getShaderInfoLog(shader));
		            return null;
		        }
		
		        return shader;
		    }
		
		    var shaderProgram;
		
		    function initShaders() {
		        var fragmentShader = getShader(gl, "shader-fs");
		        var vertexShader = getShader(gl, "shader-vs");
		
		        shaderProgram = gl.createProgram();
		        gl.attachShader(shaderProgram, vertexShader);
		        gl.attachShader(shaderProgram, fragmentShader);
		        gl.linkProgram(shaderProgram);
		
		        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
		            alert("Could not initialise shaders");
		        }
		
		        gl.useProgram(shaderProgram);
		
		        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
		        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
		
		        shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
		        gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
		
		        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
		        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
		        shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
		    }
				    
		    var texture = new Array();
		    
			function loadTexture(filePath,texture)  {
				var i = texture.length;
				texture[i] = gl.createTexture();
				texture[i].image = new Image();
			  	texture[i].image.onload = function(){
			  		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
			        gl.bindTexture(gl.TEXTURE_2D, texture[i]);
			        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture[i].image);
			        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
					
					gl.bindTexture(gl.TEXTURE_2D, null);
				}
				texture[i].image.src = filePath;
			} 
					
		    function initTexture(fileName) {
		    	var request = new XMLHttpRequest();
		        request.open("GET", "glMap.mtl");
		        request.onreadystatechange = function () {
		            if (request.readyState == 4) {
		                var lines = request.responseText.split("\n");
		                
		                for(var i=0; i<lines.length; i++){
			                var vals = lines[i].split(" ");
			                
			                if(vals[0] == "map_Kd"){
			                	loadTexture(vals[1],texture);
			                }
		                }
		            }
		        }
		        request.send();
		    }
			
		    var mvMatrix = mat4.create();
		    var mvMatrixStack = [];
		    var pMatrix = mat4.create();
		
		    function mvPushMatrix() {
		        var copy = mat4.create();
		        mat4.set(mvMatrix, copy);
		        mvMatrixStack.push(copy);
		    }
		
		    function mvPopMatrix() {
		        if (mvMatrixStack.length == 0) {
		            throw "Invalid popMatrix!";
		        }
		        mvMatrix = mvMatrixStack.pop();
		    }
		
		    function setMatrixUniforms() {
		        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
		        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
		    }
		
		
		    function degToRad(degrees) {
		        return degrees * Math.PI / 180;
		    }
		
		    var currentlyPressedKeys = {};
		
		    function handleKeyDown(event) {
		        currentlyPressedKeys[event.keyCode] = true;
		    }
		
		
		    function handleKeyUp(event) {
		        currentlyPressedKeys[event.keyCode] = false;
		    }
		
		    var pitch = 0;
		    var pitchRate = 0;
		
		    var yaw = 0;
		    var yawRate = 0;
		
		    var xPos = 0;
		    var yPos = 0.4;
		    var zPos = 0;
		
		    var speed = 0;
		
		    function handleKeys() {
		        if (currentlyPressedKeys[33]) {
		            // Page Up
		            pitchRate = 0.1;
		        } else if (currentlyPressedKeys[34]) {
		            // Page Down
		            pitchRate = -0.1;
		        } else {
		            pitchRate = 0;
		        }
		
		        if (currentlyPressedKeys[37] || currentlyPressedKeys[65]) {
		            // Left cursor key or A
		            yawRate = 0.1;
		        } else if (currentlyPressedKeys[39] || currentlyPressedKeys[68]) {
		            // Right cursor key or D
		            yawRate = -0.1;
		        } else {
		            yawRate = 0;
		        }
		
		        if (currentlyPressedKeys[38] || currentlyPressedKeys[87]) {
		            // Up cursor key or W
		            speed = 0.003;
		        } else if (currentlyPressedKeys[40] || currentlyPressedKeys[83]) {
		            // Down cursor key
		            speed = -0.003;
		        } else {
		            speed = 0;
		        }
		
		    }
		    
		    var objVertexPositionBuffer = new Array();
		    var objVertexTextureCoordBuffer = new Array();
			var allTex = [];
			var allTexCount = -1;
			var allTexLength = [];
			var uniqueTextures = [];
		
		    function handleLoadedObject(data) {
		        var lines = data.split("\n");
		        
		        var vertexCount = [];
		        var vertexPositions = [];
		        var vertexTextureCoords = [];
				var vX = [];
				var vY = [];
				var vZ = [];
				var vtX = [];
				var vtY = [];
				var vCount = 0;
				var vtCount = 0;
				
				for(var i=0; i<lines.length; i++){
					var vals = lines[i].split(" ");
					
					if(vals[0] == 'usemtl' && vals[1] != 'FrontColor'){
						allTex.push(vals[1]);
						
						if(uniqueTextures.length == 0){ 
							uniqueTextures.push(vals[1]); 
						}else{
							var isUnique = true;
							for(var a=0; a<uniqueTextures.length; a++){
								//alert(vals[1]+' - '+allTex[a]);
								if(vals[1] == uniqueTextures[a]){
									isUnique = false;
								}
							}
							if(isUnique == true){
								uniqueTextures.push(vals[1]);
							}
						}
					}
					if(vals[0] == 'v'){
						vX[vCount] = vals[1];
						vY[vCount] = vals[2];
						vZ[vCount] = vals[3];
						
						vCount++;
					}
					if(vals[0] == 'vt'){
						vtX[vtCount] = vals[1];
						vtY[vtCount] = vals[2];
						
						vtCount++;
					}
				}
				
				for(var i=0; i<lines.length; i++){
					var vals = lines[i].split(" ");
					if(vals[0] == 'usemtl' && vals[1] != 'FrontColor'){
						allTexCount++;
						allTexLength.push(0);
					}
					if(vals[0] == 'f'){
						for(var ii=1; ii<vals.length; ii++){
							var val = vals[ii].split("/");
							
							for(var iii=0; iii<uniqueTextures.length; iii++){
								if(allTex[allTexCount] == uniqueTextures[iii]){
									if(typeof vertexPositions[iii] == "undefined"){
										vertexPositions[iii] = [];
										vertexTextureCoords[iii] = [];
										vertexCount[iii] = 0;
									}
									vertexPositions[iii].push(parseFloat(vX[(val[0]-1)]));
									vertexPositions[iii].push(parseFloat(vY[(val[0]-1)]));
									vertexPositions[iii].push(parseFloat(vZ[(val[0]-1)]));
								
									vertexTextureCoords[iii].push(parseFloat(vtX[(val[1]-1)]));
			                		vertexTextureCoords[iii].push(parseFloat(vtY[(val[1]-1)]));
									
									vertexCount[iii] += 1;
								}
							}
							
							allTexLength[(allTexLength.length-1)]++;
						}
					}
				}
				
				//Create all buffers
				for(var i=0; i<uniqueTextures.length; i++){
			        objVertexPositionBuffer[i] = gl.createBuffer();
			        gl.bindBuffer(gl.ARRAY_BUFFER, objVertexPositionBuffer[i]);
			        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositions[i]), gl.STATIC_DRAW);
			        objVertexPositionBuffer[i].itemSize = 3;
			        objVertexPositionBuffer[i].numItems = vertexCount[i];
			
			        objVertexTextureCoordBuffer[i] = gl.createBuffer();
			        gl.bindBuffer(gl.ARRAY_BUFFER, objVertexTextureCoordBuffer[i]);
			        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexTextureCoords[i]), gl.STATIC_DRAW);
			        objVertexTextureCoordBuffer[i].itemSize = 2;
			        objVertexTextureCoordBuffer[i].numItems = vertexCount[i];
				}
				
		        document.getElementById("loadingtext").textContent = "";
		    }
		
		
		    function loadObject() {
		        var request = new XMLHttpRequest();
		        request.open("GET", "glMap.obj");
		        request.onreadystatechange = function () {
		            if (request.readyState == 4) {
		                handleLoadedObject(request.responseText);
		            }
		        }
		        request.send();
		    }
		
		    function drawScene() {
		        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
		        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		
		        if (objVertexTextureCoordBuffer[0] == null || objVertexPositionBuffer[0] == null || objVertexTextureCoordBuffer[1] == null || objVertexPositionBuffer[1] == null) {
		            return;
		        }
		
		        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
		
		        mat4.identity(mvMatrix);
		
		        mat4.rotate(mvMatrix, degToRad(-pitch), [1, 0, 0]);
		        mat4.rotate(mvMatrix, degToRad(-yaw), [0, 1, 0]);
		        mat4.translate(mvMatrix, [-xPos, -yPos, -zPos]);
				
				//Set all buffers and invoke all draws
				for(var i=0; i<uniqueTextures.length; i++){
			        gl.bindBuffer(gl.ARRAY_BUFFER, objVertexTextureCoordBuffer[i]);
					gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, objVertexTextureCoordBuffer[i].itemSize, gl.FLOAT, false, 0, 0);
					
					gl.bindBuffer(gl.ARRAY_BUFFER, objVertexPositionBuffer[i]);
					gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, objVertexPositionBuffer[i].itemSize, gl.FLOAT, false, 0, 0);
					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, texture[i]); 
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					
					setMatrixUniforms();	
					
					gl.drawArrays(gl.TRIANGLES, 0, objVertexPositionBuffer[i].numItems);
				}
		    }
			
		    var lastTime = 0;
		    // Used to make us "jog" up and down as we move forward.
		    var joggingAngle = 0;
		
		    function animate() {
		        var timeNow = new Date().getTime();
		        if (lastTime != 0) {
		            var elapsed = timeNow - lastTime;
		
		            if (speed != 0) {
		                xPos -= Math.sin(degToRad(yaw)) * speed * elapsed;
		                zPos -= Math.cos(degToRad(yaw)) * speed * elapsed;
		
		                joggingAngle += elapsed * 0.6; // 0.6 "fiddle factor" - makes it feel more realistic :-)
		                yPos = Math.sin(degToRad(joggingAngle)) / 20 + 0.4
		            }
		
		            yaw += yawRate * elapsed;
		            pitch += pitchRate * elapsed;
		
		        }
		        lastTime = timeNow;
		    }
		
		    function tick() {
		        requestAnimFrame(tick);
		        handleKeys();
		        drawScene();
		        animate();
		    }
			
		    function webGLStart() {
		        var canvas = document.getElementById("lesson10-canvas");
		        initGL(canvas);
		        initShaders();
		        initTexture();
		        loadObject();
		
		        gl.clearColor(0.0, 0.0, 0.0, 1.0);
		        gl.enable(gl.DEPTH_TEST);
		
		        document.onkeydown = handleKeyDown;
		        document.onkeyup = handleKeyUp;
		
		        tick();
		    }
		
		</script>
		
		<style type="text/css">
		    #loadingtext {
		        position:absolute;
		        top:250px;
		        left:150px;
		        font-size:2em;
		        color: white;
		    }
		</style>
	</head>
	<body onLoad="webGLStart();">
	    <a href="http://learningwebgl.com/blog/?p=1067">&lt;&lt; Back to Lesson 10</a><br />
	
	    <canvas id="lesson10-canvas" style="border: none;" width="500" height="500"></canvas>
	
	    <div id="loadingtext">Loading world...</div>
	
	    <br/>
	    Use the cursor keys or WASD to run around, and <code>Page Up</code>/<code>Page Down</code> to
	look up and down.
	
	    <br/>
	    <br/>
	    <a href="http://learningwebgl.com/blog/?p=1067">&lt;&lt; Back to Lesson 10</a>
	</body>
</html>