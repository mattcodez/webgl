<html>
	<head>
		<title>Learning WebGL &mdash; lesson 10</title>
		<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

		<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
		<script type="text/javascript" src="webgl-utils.js"></script>

		<script id="shader-fs" type="x-shader/x-fragment">
		    precision mediump float;
		
		    varying vec2 vTextureCoord;
		
		    uniform sampler2D uSampler;
		
		    void main(void) {
		        gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
		    }
		</script>
		
		<script id="shader-vs" type="x-shader/x-vertex">
		    attribute vec3 aVertexPosition;
		    attribute vec2 aTextureCoord;
		
		    uniform mat4 uMVMatrix;
		    uniform mat4 uPMatrix;
		
		    varying vec2 vTextureCoord;
		
		    void main(void) {
		        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		        vTextureCoord = aTextureCoord;
		    }
		</script>
		
		<script type="text/javascript">
		
		    var gl;
		
		    function initGL(canvas) {
		        try {
		            gl = canvas.getContext("experimental-webgl");
		            gl.viewportWidth = canvas.width;
		            gl.viewportHeight = canvas.height;
		        } catch (e) {
		        }
		        if (!gl) {
		            alert("Could not initialise WebGL, sorry :-(");
		        }
		    }
		
		    function getShader(gl, id) {
		        var shaderScript = document.getElementById(id);
		        if (!shaderScript) {
		            return null;
		        }
		
		        var str = "";
		        var k = shaderScript.firstChild;
		        while (k) {
		            if (k.nodeType == 3) {
		                str += k.textContent;
		            }
		            k = k.nextSibling;
		        }
		
		        var shader;
		        if (shaderScript.type == "x-shader/x-fragment") {
		            shader = gl.createShader(gl.FRAGMENT_SHADER);
		        } else if (shaderScript.type == "x-shader/x-vertex") {
		            shader = gl.createShader(gl.VERTEX_SHADER);
		        } else {
		            return null;
		        }
		
		        gl.shaderSource(shader, str);
		        gl.compileShader(shader);
		
		        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		            alert(gl.getShaderInfoLog(shader));
		            return null;
		        }
		
		        return shader;
		    }
		
		    var shaderProgram;
		
		    function initShaders() {
		        var fragmentShader = getShader(gl, "shader-fs");
		        var vertexShader = getShader(gl, "shader-vs");
		
		        shaderProgram = gl.createProgram();
		        gl.attachShader(shaderProgram, vertexShader);
		        gl.attachShader(shaderProgram, fragmentShader);
		        gl.linkProgram(shaderProgram);
		
		        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
		            alert("Could not initialise shaders");
		        }
		
		        gl.useProgram(shaderProgram);
		
		        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
		        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
		
		        shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
		        gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
		
		        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
		        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
		        shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
		    }
		
		    function handleLoadedTexture(texture) {
		        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		        gl.bindTexture(gl.TEXTURE_2D, texture);
		        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
		        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
				//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
				//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
				//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
				//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAR);
				//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAR);
		
		        gl.bindTexture(gl.TEXTURE_2D, null);
		    }
		
			var texture1;
			var texture2;
			
			var texture = new Array();
		
		    function initTexture(fileName) {
		    	var request = new XMLHttpRequest();
		        request.open("GET", "glMap.mtl");
		        request.onreadystatechange = function () {
		            if (request.readyState == 4) {
		                var lines = request.responseText.split("\n");
		                
		                for(var i=0; i<lines.length; i++){
			                var vals = lines[i].split(" ");
			                
			                if(vals[0] == "map_Kd"){
			                	var ind = ((texture.length-1) == -1 ? 0 : (texture.length));
			                	texture[ind] = gl.createTexture();
						    	texture[ind].image = new Image();
						    	texture[ind].image.onload = function(){
							    	gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
							        gl.bindTexture(gl.TEXTURE_2D, texture[ind]);
							        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture[ind].image);
							        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
									//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
							        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
									//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
									//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
									//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
									//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
									//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
									//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAR);
									//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAR);

						    	}
						    	texture[ind].image.src = vals[1];
						    	//alert(ind);
						    	/*if((texture.length-1) == 0){
							    	texture1 = gl.createTexture();
							    	texture1.image = new Image();
							    	texture1.image.onload = function(){
								    	handleLoadedTexture(texture1)
							    	}
							    	texture1.image.src = vals[1];
						    	}else if((texture.length-1) == 1){
							    	texture2 = gl.createTexture();
							    	texture2.image = new Image();
							    	texture2.image.onload = function(){
								    	handleLoadedTexture(texture2)
							    	}
							    	texture2.image.src = vals[1];
						    	}*/
			                }
		                }
		            }
		        }
		        request.send();
		    	
		    	/*
		        texture1 = gl.createTexture();
		        texture1.image = new Image();
		        texture1.image.onload = function () {
		            handleLoadedTexture(texture1)
		        }
		        texture1.image.src = "glMap/Metal_Brass_Ceiling.jpg";
				
				texture2 = gl.createTexture();
		        texture2.image = new Image();
		        texture2.image.onload = function () {
		            handleLoadedTexture(texture2)
		        }
		        texture2.image.src = "glMap/Metal_Steel_Textured_White.jpg";
		        */
		    }
			

		    var mvMatrix = mat4.create();
		    var mvMatrixStack = [];
		    var pMatrix = mat4.create();
		
		    function mvPushMatrix() {
		        var copy = mat4.create();
		        mat4.set(mvMatrix, copy);
		        mvMatrixStack.push(copy);
		    }
		
		    function mvPopMatrix() {
		        if (mvMatrixStack.length == 0) {
		            throw "Invalid popMatrix!";
		        }
		        mvMatrix = mvMatrixStack.pop();
		    }
		
		    function setMatrixUniforms() {
		        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
		        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
		    }
		
		
		    function degToRad(degrees) {
		        return degrees * Math.PI / 180;
		    }
		
		    var currentlyPressedKeys = {};
		
		    function handleKeyDown(event) {
		        currentlyPressedKeys[event.keyCode] = true;
		    }
		
		
		    function handleKeyUp(event) {
		        currentlyPressedKeys[event.keyCode] = false;
		    }
		
		    var pitch = 0;
		    var pitchRate = 0;
		
		    var yaw = 0;
		    var yawRate = 0;
		
		    var xPos = 0;
		    var yPos = 0.4;
		    var zPos = 0;
		
		    var speed = 0;
		
		    function handleKeys() {
		        if (currentlyPressedKeys[33]) {
		            // Page Up
		            pitchRate = 0.1;
		        } else if (currentlyPressedKeys[34]) {
		            // Page Down
		            pitchRate = -0.1;
		        } else {
		            pitchRate = 0;
		        }
		
		        if (currentlyPressedKeys[37] || currentlyPressedKeys[65]) {
		            // Left cursor key or A
		            yawRate = 0.1;
		        } else if (currentlyPressedKeys[39] || currentlyPressedKeys[68]) {
		            // Right cursor key or D
		            yawRate = -0.1;
		        } else {
		            yawRate = 0;
		        }
		
		        if (currentlyPressedKeys[38] || currentlyPressedKeys[87]) {
		            // Up cursor key or W
		            speed = 0.003;
		        } else if (currentlyPressedKeys[40] || currentlyPressedKeys[83]) {
		            // Down cursor key
		            speed = -0.003;
		        } else {
		            speed = 0;
		        }
		
		    }
		
		    var worldVertexPositionBuffer1 = null;
			var worldVertexPositionBuffer2 = null;
		    var worldVertexTextureCoordBuffer1 = null;
		    var worldVertexTextureCoordBuffer2 = null;	
			var vertexTextureCount1 = 0;
			var vertexTextureCount2 = 0;
			var allTex = [];
			var allTexCount = -1;
			var allTexLength = [];
		
		    function handleLoadedObject(data) {
		        var lines = data.split("\n");
		        var vertexCount1 = 0;
				var vertexCount2 = 0;
				var vertexPositions1 = [];
				var vertexPositions2 = [];
		        var vertexTextureCoords1 = [];
				var vertexTextureCoords2 = [];
				var vX = [];
				var vY = [];
				var vZ = [];
				var vtX = [];
				var vtY = [];
				var vCount = 0;
				var vtCount = 0;
				
				for(var i=0; i<lines.length; i++){
					var vals = lines[i].split(" ");
					
					if(vals[0] == 'usemtl' && vals[1] != 'FrontColor'){
						allTex.push(vals[1]);
					}
					if(vals[0] == 'v'){
						vX[vCount] = vals[1];
						vY[vCount] = vals[2];
						vZ[vCount] = vals[3];
						
						vCount++;
					}
					if(vals[0] == 'vt'){
						vtX[vtCount] = vals[1];
						vtY[vtCount] = vals[2];
						
						vtCount++;
					}
				}
				
				for(var i=0; i<lines.length; i++){
					var vals = lines[i].split(" ");
					if(vals[0] == 'usemtl' && vals[1] != 'FrontColor'){
						allTexCount++;
						allTexLength.push(0);
					}
					if(vals[0] == 'f'){
						for(var ii=1; ii<vals.length; ii++){
							var val = vals[ii].split("/");
							console.log(vertexCount1+vertexCount2
								 +' - '+parseFloat(vX[(val[0]-1)])
								 +' - '+parseFloat(vY[(val[0]-1)])
								 +' - '+parseFloat(vZ[(val[0]-1)])
								 +' - '+parseFloat(vtX[(val[1]-1)])
		                		 +' - '+parseFloat(vtY[(val[1]-1)]));
							if(allTex[allTexCount] == 'Metal_Brass_Ceiling'){
								vertexPositions1.push(parseFloat(vX[(val[0]-1)]));
								vertexPositions1.push(parseFloat(vY[(val[0]-1)]));
								vertexPositions1.push(parseFloat(vZ[(val[0]-1)]));
							
								vertexTextureCoords1.push(parseFloat(vtX[(val[1]-1)]));
		                		vertexTextureCoords1.push(parseFloat(vtY[(val[1]-1)]));
								
								vertexCount1 += 1;
		
								vertexTextureCount1++;
							}
							if(allTex[allTexCount] == 'Metal_Steel_Textured_White'){
								vertexPositions2.push(parseFloat(vX[(val[0]-1)]));
								vertexPositions2.push(parseFloat(vY[(val[0]-1)]));
								vertexPositions2.push(parseFloat(vZ[(val[0]-1)]));
								
								vertexTextureCoords2.push(parseFloat(vtX[(val[1]-1)]));
		                		vertexTextureCoords2.push(parseFloat(vtY[(val[1]-1)]));
								
								vertexCount2 += 1;
								
								vertexTextureCount2++;
							}
							
							allTexLength[(allTexLength.length-1)]++;
						}
					}
				}
				
		        worldVertexPositionBuffer1 = gl.createBuffer();
		        gl.bindBuffer(gl.ARRAY_BUFFER, worldVertexPositionBuffer1);
		        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositions1), gl.STATIC_DRAW);
		        worldVertexPositionBuffer1.itemSize = 3;
		        worldVertexPositionBuffer1.numItems = vertexCount1;
		
		        worldVertexTextureCoordBuffer1 = gl.createBuffer();
		        gl.bindBuffer(gl.ARRAY_BUFFER, worldVertexTextureCoordBuffer1);
		        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexTextureCoords1), gl.STATIC_DRAW);
		        worldVertexTextureCoordBuffer1.itemSize = 2;
		        worldVertexTextureCoordBuffer1.numItems = vertexCount1;
				
				worldVertexPositionBuffer2 = gl.createBuffer();
		        gl.bindBuffer(gl.ARRAY_BUFFER, worldVertexPositionBuffer2);
		        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositions2), gl.STATIC_DRAW);
		        worldVertexPositionBuffer2.itemSize = 3;
		        worldVertexPositionBuffer2.numItems = vertexCount2;
		
		        worldVertexTextureCoordBuffer2 = gl.createBuffer();
		        gl.bindBuffer(gl.ARRAY_BUFFER, worldVertexTextureCoordBuffer2);
		        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexTextureCoords2), gl.STATIC_DRAW);
		        worldVertexTextureCoordBuffer2.itemSize = 2;
		        worldVertexTextureCoordBuffer2.numItems = vertexCount2;
				
		        document.getElementById("loadingtext").textContent = "";
		    }
		
		
		    function loadObject() {
		        var request = new XMLHttpRequest();
		        request.open("GET", "glMap.obj");
		        request.onreadystatechange = function () {
		            if (request.readyState == 4) {
		                handleLoadedObject(request.responseText);
		            }
		        }
		        request.send();
		    }
		
		    function drawScene() {
		        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
		        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		
		        if (worldVertexTextureCoordBuffer1 == null || worldVertexPositionBuffer1 == null || worldVertexTextureCoordBuffer2 == null || worldVertexPositionBuffer2 == null) {
		            return;
		        }
		
		        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
		
		        mat4.identity(mvMatrix);
		
		        mat4.rotate(mvMatrix, degToRad(-pitch), [1, 0, 0]);
		        mat4.rotate(mvMatrix, degToRad(-yaw), [0, 1, 0]);
		        mat4.translate(mvMatrix, [-xPos, -yPos, -zPos]);
				
				gl.bindBuffer(gl.ARRAY_BUFFER, worldVertexTextureCoordBuffer1);
				gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, worldVertexTextureCoordBuffer1.itemSize, gl.FLOAT, false, 0, 0);
				
				gl.bindBuffer(gl.ARRAY_BUFFER, worldVertexPositionBuffer1);
				gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, worldVertexPositionBuffer1.itemSize, gl.FLOAT, false, 0, 0);
				//alert(texture[1].image.src)
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture[0]); 
				gl.uniform1i(shaderProgram.samplerUniform, 0);
				
				setMatrixUniforms();	
				
				gl.drawArrays(gl.TRIANGLES, 0, worldVertexPositionBuffer1.numItems);
				
				gl.bindBuffer(gl.ARRAY_BUFFER, worldVertexTextureCoordBuffer2);
				gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, worldVertexTextureCoordBuffer2.itemSize, gl.FLOAT, false, 0, 0);
				
				gl.bindBuffer(gl.ARRAY_BUFFER, worldVertexPositionBuffer2);
				gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, worldVertexPositionBuffer2.itemSize, gl.FLOAT, false, 0, 0);
				
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture[1]); 
				gl.uniform1i(shaderProgram.samplerUniform, 0);
				
				setMatrixUniforms();	
				
				gl.drawArrays(gl.TRIANGLES, 0, worldVertexPositionBuffer2.numItems);
				/*
				var total = 0;
				for(var i=0; i<allTex.length; i++){
					//alert(total+' - '+(total + allTexLength[i])+' - '+allTexLength[i]+' - '+allTex.length);
					gl.activeTexture(gl.TEXTURE0);
					if(allTex[i] == 'Metal_Brass_Ceiling'){ 
						gl.bindTexture(gl.TEXTURE_2D, texture1); 
					}else{
						gl.bindTexture(gl.TEXTURE_2D, texture2); 
					}
					gl.uniform1i(shaderProgram.samplerUniform, 0);
					
					setMatrixUniforms();			
					gl.drawArrays(gl.TRIANGLES, total, (total + allTexLength[i])); 
					
					total = (total + allTexLength[i]);
				}*/
		    }
			
		    var lastTime = 0;
		    // Used to make us "jog" up and down as we move forward.
		    var joggingAngle = 0;
		
		    function animate() {
		        var timeNow = new Date().getTime();
		        if (lastTime != 0) {
		            var elapsed = timeNow - lastTime;
		
		            if (speed != 0) {
		                xPos -= Math.sin(degToRad(yaw)) * speed * elapsed;
		                zPos -= Math.cos(degToRad(yaw)) * speed * elapsed;
		
		                joggingAngle += elapsed * 0.6; // 0.6 "fiddle factor" - makes it feel more realistic :-)
		                yPos = Math.sin(degToRad(joggingAngle)) / 20 + 0.4
		            }
		
		            yaw += yawRate * elapsed;
		            pitch += pitchRate * elapsed;
		
		        }
		        lastTime = timeNow;
		    }
		
		    function tick() {
		        requestAnimFrame(tick);
		        handleKeys();
		        drawScene();
		        animate();
		    }
			
		    function webGLStart() {
		        var canvas = document.getElementById("lesson10-canvas");
		        initGL(canvas);
		        initShaders();
		        initTexture();
		        loadObject();
		
		        gl.clearColor(0.0, 0.0, 0.0, 1.0);
		        gl.enable(gl.DEPTH_TEST);
		
		        document.onkeydown = handleKeyDown;
		        document.onkeyup = handleKeyUp;
		
		        tick();
		    }
		
		</script>
		
		<style type="text/css">
		    #loadingtext {
		        position:absolute;
		        top:250px;
		        left:150px;
		        font-size:2em;
		        color: white;
		    }
		</style>
	</head>
	<body onLoad="webGLStart();">
	    <a href="http://learningwebgl.com/blog/?p=1067">&lt;&lt; Back to Lesson 10</a><br />
	
	    <canvas id="lesson10-canvas" style="border: none;" width="500" height="500"></canvas>
	
	    <div id="loadingtext">Loading world...</div>
	
	    <br/>
	    Use the cursor keys or WASD to run around, and <code>Page Up</code>/<code>Page Down</code> to
	look up and down.
	
	    <br/>
	    <br/>
	    <a href="http://learningwebgl.com/blog/?p=1067">&lt;&lt; Back to Lesson 10</a>
	</body>
</html>